---
title: "前端组件库设计"
date: 2022-05-17 09:07
status: ondo
tags:
- UILibrary
- DesignPrinciple
---

# 前端组件库的设计原则

## 细粒度的考量

设计模式: **单一职责原则**

所以，所谓的单一职责组件要建立在可复用的基础上，对于不可复用的单一职责组件我们仅仅作为独立组件的内部组件即可。

## 通用性考量

Antd 依赖了大量以`rc-`开头的底层组件, 这些组件被 react-component 团队 (同时也就是 Antd 团队) 维护, 其主要实现组件的底层逻辑, Antd 则是在此基础上添加 Ant Design 设计语言而实现的

当然类似的设计还有很多, 通用性设计其实是一定意义上放弃对 DOM 的掌控, 而将 DOM 结构的决定权转移给开发者,`dropdownRender`其实就是放弃对 Select 下拉菜单中条目的掌控, Antd 的 Select 组件其实还有一个没有在文档中体现的方法`getInputElement`应该是对 Input 组件的自定义方法, Antd 整个 Select 的组件设计非常复杂, 基本将所有的 DOM 结构控制权全部暴露给了开发者, 其本身只负责底层逻辑和最基本的 DOM 结构.

那么这么多需要自定义的地方, 这个 Select 组件岂不是很难用? 因为好像所有地方都需要开发者自定义, 通用性设计在将 DOM 结构决定权交给开发者的同时也保留了默认结构, 在开发者没有显示自定义的时候默认使用默认渲染结构, 其实 Select 的基本使用很方便, 如下:

```html
<select defaultvalue="lucy" style={{ width: 120 }} disabled>
	<Option value="lucy">Lucy</Option>
	<Option value="luka">Luka</Option>
</Select>
```

组件的形态 (DOM 结构) 永远是千变万化的, 但是其行为 (逻辑) 是固定的, 因此通用组件的秘诀之一就是将 DOM 结构的控制权交给开发者, 组件只负责行为和最基本的 DOM 结构

# 技术选型

## css 解决方案

由于 CSS 本身的众多缺陷，如书写繁琐（不支持嵌套）、样式易冲突（没有作用域概念）、缺少变量（不便于一键换主题）等不一而足。为了解决这些问题，社区里的解决方案也是出了一茬又一茬，从最早的 `CSS prepocessor`（`SASS`、`LESS`、`Stylus`）到后来的后起之秀 `PostCSS`，再到 `CSS Modules`、`Styled-Components` 等。

Antd 选择了 less 作为 css 的预处理方案, Bootstrap 选择了 Scss, 这两种方案孰优孰劣已经争论了很多年了:

SCSS 和 LESS 相比有什么优势？

但是不管是哪种方案都有一个很烦人的点, 就是需要额外引入 css, 比如 Antd 需要这样显示引入:

```js
import Button from 'antd/lib/button'
import 'antd/lib/button/style';
```

为了解决这种尴尬的情况, Antd 用 Babel 插件将这种情况 Hack 掉了

而 `material-ui` 用 `jss` 作为 css-in-js 的解决方案, jsx 的引入已经将 js 和 html 耦合, css-in-js 将 css 也耦合进去, 此时组件便不需要显示引入 css, 而是直接引用 js 即可, jsx 已经将 js 和 html 框定到一个组件中, css 依然处于分离状态, 这就导致了每次引用组件却还需要显示引入 css,css-in-js 正式彻底组件化的解决方案。

### styled-components

1.  styled-components 所有语法都是标准 css 语法，同时支持 scss 嵌套等常用语法，覆盖了所有 css 场景。
2.  在样式复写场景下，styled-components 支持在任何地方注入全局 css，就像写普通 css 一样
3.  styled-components 支持自定义 className，两种方式，一种是用 babel 插件, 另一种方式是使用 styled.div.withConfig({componentId: "prefix-button-container"}) 相当于添加 className="prefix-button-container"
4.  className 语义化更轻松，这也是 class 起名的初衷
5.  更适合组件库使用，直接引用 import "module" 即可，否则你有三条路可以走：像 antd 一样，单独引用 css，你需要给 node_modules 添加 css-loader；组件内部直接 import css 文件，如果任何业务项目没有 css-loader 就会报错；组件使用 scss 引用，所有业务项目都要配置一份 scss-loader 给 node_modules；这三种对组件库来说，都没有直接引用来的友好
6.  当你写一套组件库，需要单独发包，又有统一样式的配置文件需求，如果这个配置文件是 js 的，所有组件直接引用，对外完全不用关注。否则，如果是 scss 配置文件，摆在面前还是三条路：每个组件单独引用 scss 文件，需要每个业务项目给 node_modules 添加 scss-loader（如果业务用了 less，还要装一份 scss 是不）；或者业务方只要使用了你的组件库，就要在入口文件引用你的 scss 文件，比如你的组件叫 button，scss 可能叫 common-css，别人听都没听过，还要查文档；或者业务方在 webpack 配置中单独引用你的 common-css，这也不科学，如果用了 3 个组件库，天天改 webpack 配置也很不方便。
7.  当 css 设置了一半样式，另一半真的需要 js 动态传入，你不得不 css + css-in-js 混合使用，项目久了，维护的时候发现某些 css-in-js 不变了，可以固化在 css 里，css 里固定的值又因为新去求变得可变了，你又得拿出来放在 css-in-js 里，实践过就知道有多么烦心。

## js 解决方案

选 Typescript , 因为巨硬大法好…

可以看看知乎问题下我的回答你为什么不用 Typescript

或者看此文 TypeScript 体系调研报告

* * *

# 如何快速启动一个组件库项目

组件的具体实现部分当然是组件库的核心, 但是在现代前端库中其他部分也必不可少, 我们需要一堆工具来辅助我们开发, 例如编译工具、代码检测工具、打包工具等等。

## 打包工具 (rollup vs webpack)

市面上打包工具数不胜数, 最火爆的当然是需要_配置工程师_专门配置的 webpack, 但是在类库开发领域它有一个强大的对手就是 rollup。

现代市面上主流的库基本都选择了 rollup 作为打包工具，包括 Angular React 和 Vue, 作为基础类库的打包工具 rollup 的优势如下:

*   Tree Shaking: 自动移除未使用的代码, 输出更小的文件
*   Scope Hoisting: 所有模块构建在一个函数内, 执行效率更高
*   Config 文件支持通过 ESM 模块格式书写  
    可以一次输出多种格式:
*   模块规范: IIFE, AMD, CJS, UMD, ESM  
    Development 与 production 版本: .js, .min.js
    

虽然上面部分功能已经被 webpack 实现了, 但是 rollup 明显引入得更早, 而 Scope Hoisting 更是杀手锏, 由于 webpack 不得不在打包代码中构建模块系统来适应 app 开发 (模块系统对于单一类库用处很小),Scope Hoisting 将模块构建在一个函数内的做法更适合类库的打包.

## 代码检测

由于 JavaScript 各种诡异的特性和大型前端项目的出现, 代码检测工具已经是前端开发者的标配了, Douglas Crockford 最早于 2002 创造出了 JSLint, 但是其无法拓展, 具有极强的 Douglas Crockford 个人色彩, Anton Kovalyov 由于无法忍受 JSLint 无法拓展的行为在 2011 年发布了可拓展的 JSHint, 一时之间 JSHint 成为了前端代码检测的流行解决方案.

随后的 2013 年, Nicholas C. Zakas 鉴于 JSHint 拓展的灵活度不够的问题开发了全新的基于 AST 的 Lint 工具 ESLint, 并随着 ES6 的流行统治了前端界, ESLint 基于 Esprima 进行 JavaScript 解析的特性极易拓展, JSHint 在很长一段时间无法支持 ES6 语法导致被 ESLint 超越.

但是在 Typescript 领域 ESLint 却处于弱势地位, TSLint 的出现要比 ESLint 正式支持 Typescript 早很多, 目前 TSLint 似乎是 TS 的事实上的代码检测工具.

注: 文章成文较早, 我也没想到前阵子 TS 官方钦点了 ESLint,TSLint 失宠了, 面向未来的官方标配的代码检测工具肯定是 ESLint 了, 但是 TSLint 目前依然被大量使用, 现在仍然可以放心使用

代码检测工具是一方面, 代码检测风格也需要我们做选择, 市面上最流行的代码检测风格应该是 Airbnb 出品的`eslint-config-airbnb`, 其最大的特点就是极其严格, 没有给开发者任何选择的余地, 当然在大型前端项目的开发中这种严格的代码风格是有利于协作的, 但是作为一个类库的代码检测工具而言并不适合, 所以我们选择了`eslint-config-standard`这种相对更为宽松的代码检测风格.

## commit 规范

目前流行的方案是 Angular 团队的规范, 其关于 head 的大致规范如下:

*   type: commit 的类型
    
*   feat: 新特性
    
*   fix: 修改问题
    
*   refactor: 代码重构
    
*   docs: 文档修改
    
*   style: 代码格式修改, 注意不是 css 修改
    
*   test: 测试用例修改
    
*   chore: 其他修改, 比如构建流程, 依赖管理.
    
*   scope: commit 影响的范围, 比如: route, component, utils, build…
    
*   subject: commit 的概述, 建议符合  50/72 formatting
    
*   body: commit 具体修改内容, 可以分为多行, 建议符合 50/72 formatting
    
*   footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接.
    

当然规范人们不一定会遵守, 我最初知道此类规范的时候也并没有严格遵循, 因为人总会偷懒, 直到用`commitizen`将此规范集成到工具流中, 每个 commit 就不得不遵循规范了.

我具体参考了这篇文章: 优雅的提交你的 Git Commit Message

## 测试工具

业务开发中由于前端需求变动频繁的特性, 导致前端对测试的要求并没有后端那么高, 后端业务逻辑一旦定型变动很少, 比较适合测试.

但是基础类库作为被反复依赖的模块和较为稳定的需求是必须做测试的, 前端测试库也可谓是种类繁多了, 经过比对之后我还是选择了目前最流行也是被三大框架同时选择了的 Jest 作为测试工具, 其优点很明显:

1.  开箱即用, 内置断言、测试覆盖率工具, 如果你用 MoCha 那可得自己手动配置 n 多了
    
2.  快照功能, Jest 可以利用其特有的快照测试功能，通过比对 UI 代码生成的快照文件
    
3.  速度优势, Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度
    

## 其它

当然以上是主要工具的选择, 还有一些比如:

*   代码美化工具 prettier, 解放人肉美化, 同时利于不同人协作的风格一致
    
*   持续集成工具 travis-ci, 解放人肉测试 lint, 利于保证每次 push 的可靠程度
    

## 快速启动脚手架

那么以上这么多配置难道要我们每次都自己写吗? 组件的具体实现才是组件库的核心, 我们为什么要花这么多时间在配置上面?

我们在建立 APP 项目时通常会用到框架官方提供的脚手架, 比如 React 的 create-react-app,Angular 的 Angular-Cli 等等, 那么能不能有一个专门用于组件开发的快速启动的脚手架呢?

有的, 我最近开发了一款快速启动组件库开发的命令行工具 --create-component

https://github.com/xiaomuzhu/create-component

利用

```
1create-component init
```

来快速启动项目, 我们提供了丰富的可选配置, 只要你做好技术选型后, 根据提示去选择配置即可, create-component 会自动根据配置生成脚手架, 其灵感就来源于 vue-cli 和 Angular-cli.

![](https://mmbiz.qpic.cn/mmbiz_png/Fq2ZIx64zaS4tibZa1T9umAGwyxgyeYL24icZfP86PzoylupHozC3VZABdl0SPY2eoCZiaVibRGTzjbXOTibVdzswyQ/640?wx_fmt=png)

* * *

# 如何设计一个轮播图组件

说了很多理论, 那么实战如何呢? 设计一个通用组件试试吧!

## 轮播图基本原理

轮播图 (Carousel), 在 Antd 中被称为走马灯, 可能是前端开发者最常见的组件之一了, 不管是在 PC 端还是在移动端我们总能见到他的身影.  

![](https://mmbiz.qpic.cn/mmbiz_png/Fq2ZIx64zaS4tibZa1T9umAGwyxgyeYL2q1hzVcxqAjRtsgMQKS2XDXVDVkqK51X2DukFQu6bbJ3p7IXjbnUVuA/640?wx_fmt=png)

那么我们通常是如何使用轮播图的呢? Antd 的代码如下

```
1  <Carousel>2    <div><h3>1h3>div>3    <div><h3>2h3>div>4    <div><h3>3h3>div>5    <div><h3>4h3>div>6  Carousel>
```

问题是我们在`Carousel`中放入了四组`div`为什么一次只显示一组呢?

![](https://mmbiz.qpic.cn/mmbiz_png/Fq2ZIx64zaS4tibZa1T9umAGwyxgyeYL2olUUGgpw5rRXGAHSgYR7KEpVDNqfTMqqO02nuO113V3GYUlcmaHW9A/640?wx_fmt=png)

图中被红框圈住的为可视区域, 可视区域的位置是固定的, 我们只需要移动后面`div`的位置就可以做到 1 2 3 4 四个子组件轮播的效果, 那么子组件 2 目前在可视区域是可以被看到的, 1 3 4 应该被隐藏, 这就需要我们设置 overflow 属性为 hidden 来隐藏非可视区域的子组件.

复制查看动图: https://images2015.cnblogs.com/blog/979044/201707/979044-20170710105934040-1007626405.gif

因此就比较明显了, 我们设计一个可视窗口组件`Frame`, 然后将四个 `div`共同放入幻灯片组合组件`SlideList`中, 并用`SlideItem`分别将 `div`包裹起来, 实际代码应该是这样的:

```
1 <Frame> 2    <SlideList> 3        <SlideItem> 4            <div><h3>1h3>div>   5        SlideItem> 6        <SlideItem> 7            <div><h3>2h3>div>   8        SlideItem> 9        <SlideItem>10            <div><h3>3h3>div>  11        SlideItem>12        <SlideItem>13            <div><h3>4h3>div>  14        SlideItem>15    SlideList>16  Frame>
```

我们不断利用`translateX`来改变`SlideList`的位置来达到轮播效果, 如下图所示, 每次轮播的触发都是通过改变`transform: translateX()`来操作的

![](https://mmbiz.qpic.cn/mmbiz_png/Fq2ZIx64zaS4tibZa1T9umAGwyxgyeYL2zdickHzzRNPgRTHdtTjJRU1pu3NYNekicXU9OdC2icMHoybLV5rrtSw6w/640?wx_fmt=png)

## 轮播图基础实现

搞清楚基本原理那么实现起来相对容易了, 我们以移动端的实现为例, 来实现一个基础的移动端轮播图.

首先我们要确定**可视窗口**的宽度, 因为我们需要这个宽度来计算出`SlideList`的长度 (`SlideList`的长度通常是可视窗口的倍数, 比如要放三张图片, 那么`SlideList`应该为可视窗口的至少 3 倍), 不然我们无法通过`translateX`来移动它.

我们通过`getBoundingClientRect`来获取可视区域真实的长度,`SlideList`的长度那么为:

`slideListWidth = (len + 2) * width`(len 为传入子组件的数量, width 为可视区域宽度)

至于为什么要`+2`后面会提到.

```
1  /** 2   * 设置轮播区域尺寸 3   * @param x 4   */ 5  private setSize(x?: number) { 6    const { width } = this.frameRef.current!.getBoundingClientRect() 7    const len = React.Children.count(this.props.children) 8    const total = len + 2 910    this.setState({11      slideItemWidth: width,12      slideListWidth: total * width,13      total,14      translateX: -width * this.state.currentIndex,15      startPositionX: x !== undefined ? x : 0,16    })17  }
```

获取到了总长度之后如何实现轮播呢? 我们需要根据用户反馈来触发轮播, 在移动端通常是通过手指滑动来触发轮播, 这就需要三个事件`onTouchStart` `onTouchMove` `onTouchEnd`.

![](https://mmbiz.qpic.cn/mmbiz_png/Fq2ZIx64zaS4tibZa1T9umAGwyxgyeYL2qvA4T3EIqlYXYt9ia60KMzH8Eibkpu8ZCap9pWqAYRQUguJwWdOTZQJw/640?wx_fmt=png)

`onTouchStart`顾名思义是在手指触摸到屏幕时触发的事件, 在这个事件里我们只需要记录下手指触摸屏幕的横轴坐标 x 即可, 因为我们会通过其横向滑动的距离大小来判断是否触发轮播

```
1  /** 2   * 处理触摸起始时的事件 3   * 4   * @private 5   * @param {React.TouchEvent} e 6   * @memberof Carousel 7   */ 8  private onTouchStart(e: React.TouchEvent) { 9    clearInterval(this.autoPlayTimer)10    // 获取起始的横轴坐标11    const { x } = getPosition(e)12    this.setSize(x)13    this.setState({14      startPositionX: x,15    })16  }
```

`onTouchMove`顾名思义是处于滑动状态下的事件, 此事件在`onTouchStart`触发后,`onTouchEnd`触发前, 在这个事件中我们主要做两件事, 一件事是判断滑动方向, 因为用户可能向左或者向右滑动, 另一件事是让轮播图跟随手指移动, 这是必要的用户反馈.

```
1 /** 2   * 当触摸滑动时处理事件 3   * 4   * @private 5   * @param {React.TouchEvent} e 6   * @memberof Carousel 7   */ 8  private onTouchMove(e: React.TouchEvent) { 9    const { slideItemWidth, currentIndex, startPositionX } = this.state10    const { x } = getPosition(e)1112    const deltaX = x - startPositionX13    // 判断滑动方向14    const direction = deltaX > 0 ? 'right' : 'left'1516    this.setState({17      direction,18      moveDeltaX: deltaX,19      // 改变translateX来达到轮播组件跟随手指移动的效果20      translateX: -(slideItemWidth * currentIndex) + deltaX,21    })22  }
```

`onTouchEnd`顾名思义是滑动完毕时触发的事件, 在此事件中我们主要做一个件事情, 就是判断是否触发轮播, 我们会设置一个阈值`threshold`, 当滑动距离超过这个阈值时才会触发轮播, 毕竟没有阈值的话用户稍微触碰轮播图就造成轮播, 误操作会造成很差的用户体验.

```
1  /** 2   * 滑动结束处理的事件 3   * 4   * @private 5   * @memberof Carousel 6   */ 7  private onTouchEnd() { 8    this.autoPlay() 9    const { moveDeltaX, slideItemWidth, direction } = this.state10    const threshold = slideItemWidth * THRESHOLD_PERCENTAGE11    // 判断是否轮播12    const moveToNext = Math.abs(moveDeltaX) > threshold1314    if (moveToNext) {15        // 如果轮播触发那么进行轮播操作16      this.handleSwipe(direction!)17    } else {18        // 轮播不触发,那么轮播图回到原位19      this.handleMisoperation()20    }21  }
```

## 轮播图的动画效果

我们常见的轮播图肯定不是生硬的切换, 一般在轮播中会有一个渐变或者缓动的动画, 这就需要我们加入动画效果.

我们制作动画通常有两个选择, 一个是用 css3 自带的动画效果, 另一个是用浏览器提供的 requestAnimationFrame API

孰优孰劣? css3 简单易用上手快, 兼容性好,`requestAnimationFrame` 灵活性更高, 能实现 css3 实现不了的动画, 比如众多缓动动画 css3 都束手无策, 因此我们毫无疑问地选择了`requestAnimationFrame`.

双方对比请看张鑫旭大神的 CSS3 动画那么强，requestAnimationFrame 还有毛线用？

想用`requestAnimationFrame`实现缓动效果就需要特定的缓动函数, 下面就是典型的缓动函数

```
1type tweenFunction = (t: number, b: number, _c: number, d: number) => number2const easeInOutQuad: tweenFunction = (t, b, _c, d) => {3    const c = _c - b;4    if ((t /= d / 2) < 1) {5      return c / 2 * t * t + b;6    } else {7      return -c / 2 * ((--t) * (t - 2) - 1) + b;8    }9}
```

缓动函数接收四个参数, 分别是:

*   t: 时间
    
*   b: 初始位置
    
*   _c: 结束的位置
    
*   d: 速度
    

通过这个函数我们能算出每一帧轮播图所在的位置, 如下:  

![](https://mmbiz.qpic.cn/mmbiz_png/Fq2ZIx64zaS4tibZa1T9umAGwyxgyeYL2kAffPFvfG6KHyLFllibI3R0jZpOqiaHVpZIRINM9pSJEoF1hswLjyM5Q/640?wx_fmt=png)

在获取每一帧对应的位置后, 我们需要用`requestAnimationFrame`不断递归调用依次移动位置, 我们不断调用`animation`函数是其触发函数体内的`this.setState({ translateX: tweenQueue[0], })`来达到移动轮播图位置的目的, 此时将这数组内的 30 个位置依次快速执行就是一个缓动动画效果.

```
1  /** 2   * 递归调用,根据轨迹运动 3   * 4   * @private 5   * @param {number[]} tweenQueue 6   * @param {number} newIndex 7   * @memberof Carousel 8   */ 9  private animation(tweenQueue: number[], newIndex: number) {10    if (tweenQueue.length < 1) {11      this.handleOperationEnd(newIndex)12      return13    }14    this.setState({15      translateX: tweenQueue[0],16    })17    tweenQueue.shift()18    this.rafId = requestAnimationFrame(() => this.animation(tweenQueue, newIndex))19  }
```

但是我们发现了一个问题, 当我们移动轮播图到最后的时候, 动画出现了问题, _当我们向左滑动最后一个轮播图`div4`时, 这种情况下应该是图片向左滑动, 然后第一张轮播图`div1`进入可视区域, 但是反常的是图片快速向右滑动`div1`出现在可是区域…_

因为我们此时将位置 4 设置为了位置 1, 这样才能达到不断循环的目的, 但是也造成了这个副作用, 图片行为与用户行为产生了相悖的情况 (用户向左划动, 图片向右走).

目前业界的普遍做法是将图片首尾相连, 例如图片 1 前面连接一个图片 4, 图片 4 后跟着一个图片 1, 这就是为什么之前计算长度时要`+2`

`slideListWidth = (len + 2) * width`(len 为传入子组件的数量, width 为可视区域宽度)  

![](https://mmbiz.qpic.cn/mmbiz_png/Fq2ZIx64zaS4tibZa1T9umAGwyxgyeYL24FAiaz0ZhFl0mduOk76TUFBssrDmoL7osndzkJNInWHYGzZU8KDt2Cg/640?wx_fmt=png)

当我们移动图片 4 时就不会出现上述向左滑图片却向右滑的情况, 因为真实情况是:

`图片4 -- 滑动为 -> 伪图片1` 也就是位置 5 变成了位置 6

当动画结束之后, 我们迅速把`伪图片1`的位置设置为`真图片1`, 这其实是个障眼法, 也就是说动画执行过程中实际上是`图片4`到`伪图片1`的过程, 当结束后我们偷偷把`伪图片1`换成`真图片1`, 因为两个图一模一样, 所以这个转换的过程用户根本看不出来…

如此一来我们就可以实现无缝切换的轮播图了

## 改进方向

我们实现了轮播图的基本功能, 但是其通用性依然存在缺陷:

1.  提示点的自定义: 我的实现是一个小点, 而 antd 是用的条, 这个地方完全可以将 dom 结构的决定权交给开发者.
    

![](https://mmbiz.qpic.cn/mmbiz_png/Fq2ZIx64zaS4tibZa1T9umAGwyxgyeYL2xteEicAYm5tCqfGe6aC1kMLXces5jjCdnXGXBPeNnoBWERmkFnhINRA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Fq2ZIx64zaS4tibZa1T9umAGwyxgyeYL22BLzlU6QHkT9iaR3pNLiaiblZHL5xjjNAuWlMOmnWjeyAEXIX7yMsdlcw/640?wx_fmt=png)

2.  方向的自定义: 本轮播图只有水平方向的实现, 其实也可以有纵向轮播
    

![](https://mmbiz.qpic.cn/mmbiz_png/Fq2ZIx64zaS4tibZa1T9umAGwyxgyeYL2TsuXJqstVYdF7g1zx78frlU6gIJr8xaVZ9n43lgcutxVccibo2UQptw/640?wx_fmt=png)

3.  多张轮播: 除了单张轮播也可以多张轮播
    

![](https://mmbiz.qpic.cn/mmbiz_png/Fq2ZIx64zaS4tibZa1T9umAGwyxgyeYL2mcfHpWdIsmwWWDUXRKAR6JX9SwsNkaRIib6B0yaU7jReRJ2FOd4YyAw/640?wx_fmt=png)

以上都是可以对轮播图进行拓展的方向, 相关的还有性能优化方面

我们的具体代码中有一个相关实现, 我们的轮播图其实是有自动轮播功能的, 但是很多时候页面并不在用户的可视页面中, 我们可以根据是否页面被隐藏来取消定时器终止自动播放.

![](https://mmbiz.qpic.cn/mmbiz_png/Fq2ZIx64zaS4tibZa1T9umAGwyxgyeYL2uSicgAyCxgribC0PxDiaTI1Qq6QqEk1gvJicmG0c61MjQzIEcNsa9vl98g/640?wx_fmt=png)

github 项目地址

https://github.com/xiaomuzhu/rc-carousel

以上 demo 仅供参考, 实际项目开发中最好还是使用成熟的开源组件, 要有造轮子的能力和不造轮子的觉悟