#Internet/WebBrowser

# 浏览器高层结构

1.  **用户界面** - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。
2.  **浏览器引擎** - 在用户界面和呈现引擎之间传送指令。
3.  **呈现引擎** - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
4.  **网络** - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。
5.  **用户界面后端** - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
6.  **JavaScript 解释器**。用于解析和执行 JavaScript 代码。
7.  **数据存储**。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库

![](https://gitee.com/chick-lee/typroa_-image_-repo/raw/master/image/202201261438296.png)

# Rendering Engine 呈现引擎 

>默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。

Firefox、Chrome 浏览器和 Safari是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。

## Main Flow

![](https://gitee.com/chick-lee/typroa_-image_-repo/raw/master/image/202201261449245.png)

呈现引擎开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树(Render Tree)。

呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。

呈现树构建完毕之后，进入布局(Layout) 处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是 绘制(Painting) - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。

**PS** 这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。

## Main Flow Examples

### WebKit Main Flow
![](https://gitee.com/chick-lee/typroa_-image_-repo/raw/master/image/202201261500863.png)

### Mozilla's Gecko rendering engine main flow
![](https://gitee.com/chick-lee/typroa_-image_-repo/raw/master/image/202201261501778.png)

# Parsing and DOM tree construction 解析和DOM树构建

解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。

解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为 [[与上下文无关的语法]]。人类语言并不属于这样的语言，因此无法用常规的解析技术进行解析。

## Parsing

### Parser–Lexer combination

>解析器负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。其过程可以分成两个子过程：词法分析和语法分析

解析器通常将解析工作分给以下两个组件来处理：
- **词法分析器**（有时也称为标记生成器），负责将输入内容分解成一个个有效标记，词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词；
- **语法分析**，是应用语言的语法规则的过程。

### Formal definitions for vocabulary and syntax

词汇通常用 [[正则表达式]] 表示。例如，我们的加减计算语言可以定义如下：
```
INTEGER :0|[1-9][0-9]* 
PLUS : + 
MINUS: -
```
语法通常使用一种称为 **BNF** 的格式来定义。我们的示例语言可以定义如下：
```
expression := term  operation  term
operation := PLUS | MINUS
term := INTEGER | expression
```

### Types of parsers

有两种基本类型的解析器：自上而下解析器和自下而上解析器。直观地来说，自上而下的解析器从语法的高层结构出发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则:

- 自上而下的解析器会从高层的规则开始：首先将 `2 + 3` 标识为一个表达式，然后将 `2 + 3 - 1` 标识为一个表达式（标识表达式的过程涉及到匹配其他规则，但是起点是最高级别的规则）。

- 自下而上的解析器将扫描输入内容，找到匹配的规则后，将匹配的输入内容替换成规则。如此继续替换，直到输入内容的结尾。部分匹配的表达式保存在解析器的堆栈中。

### Generating parsers automatically

> **解析器生成器**。只要向其提供所用语言的语法（词汇和语法规则），它就会生成相应的解析器。创建解析器需要对解析有深刻理解，而人工创建并优化解析器并不是一件容易的事情，所以解析器生成器是非常实用的。

WebKit 使用了两种非常有名的解析器生成器：用于创建词法分析器的 **Flex** 以及用于创建解析器的 **Bison**（Lex / Yacc ）。Flex 的输入是包含标记的正则表达式定义的文件。Bison 的输入是采用 BNF 格式的语言语法规则。

## HTML Parser

>HTML 解析器的任务是将 HTML 标记解析成解析树。

- DTD（Document Type Definition，文档类型定义）格式，非与上下文无关语法，属于 **标准通用标记语言**（Standard Generalized Markup Language，**SGML**），是现时常用的超文本格式的最高层次标准，是可以定义标记语言的元语言，甚至可以定义不必采用< >的常规方式。由于它的复杂，因而难以普及。
- 区别于 XML ，HTML 的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性”的语法。
- HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 XML 解析器来解析。

### DOM
解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。  

### The parsing algorithm
解析算法算法由两个阶段组成：标记化和树构建。标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。

#### The tokenization algorithm 标记化算法

基本示例 - 将下面的 HTML 代码标记化：
```html
<html>
	<body> 
		Hello world 
	</body> 
</html>
```

![](https://gitee.com/chick-lee/typroa_-image_-repo/raw/master/image/202201271732813.png)

初始状态是数据状态。遇到字符 `<` 时，状态更改为 **“标记打开状态”**。接收一个 `a-z` 字符会创建 **“起始标记”**，状态更改为 **“标记名称状态”**。这个状态会一直保持到接收 `>` 字符。在此期间接收的每个字符都会附加到新的标记名称上。在本例中，我们创建的标记是 `html` 标记。

遇到 `>` 标记时，会发送当前的标记，状态改回 **“数据状态”**。`<body>` 标记也会进行同样的处理。目前 `html` 和 `body` 标记均已发出。现在我们回到 **“数据状态”**。接收到 `Hello world` 中的 `H` 字符时，将创建并发送字符标记，直到接收 `</body>` 中的 `<`。我们将为 `Hello world` 中的每个字符都发送一个字符标记。

现在我们回到 **“标记打开状态”**。接收下一个输入字符 `/` 时，会创建 `end tag token` 并改为 **“标记名称状态”**。我们会再次保持这个状态，直到接收 `>`。然后将发送新的标记，并回到 **“数据状态”**。`</html>` 输入也会进行同样的处理。

#### Tree construction algorithm 树构建算法

示例输入的树构建过程：
```html
<html>
	<body> 
		Hello world 
	</body> 
</html>
```

![](https://gitee.com/chick-lee/typroa_-image_-repo/raw/master/image/202201281045591.png)

树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是 **“initial mode”**。接收 HTML 标记后转为 **“before html”** 模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。

然后状态将改为 **“before head”**。此时我们接收“body”标记。即使我们的示例中没有“head”标记，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。

现在我们进入了 **“in head”** 模式，然后转入 **“after head”** 模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为**“in body”**。

现在，接收由“Hello world”字符串生成的一系列字符标记。接收第一个字符时会创建并插入“Text”节点，而其他字符也将附加到该节点。

接收 body 结束标记会触发 **“after body”** 模式。现在我们将接收 HTML 结束标记，然后进入 **“after after body”** 模式。接收到文件结束标记后，解析过程就此结束。

#### Browsers' error tolerance 浏览器的容错机制

您在浏览 HTML 网页时从来不会看到“语法无效”的错误。这是因为浏览器会纠正任何无效内容，然后继续工作。

以下面的 HTML 代码为例：
```html
<html> 
	<mytag> 
	</mytag> 
	<div> 
	<p> 
	</div> Really lousy HTML 
	</p> 
</html>
```

在这里，已经违反了很多语法规则（“mytag”不是标准的标记，“p”和“div”元素之间的嵌套有误等等），但是浏览器仍然会正确地显示这些内容，并且毫无怨言。因为有大量的解析器代码会纠正 HTML 网页作者的错误。

不同浏览器的错误处理机制相当一致，但令人称奇的是，这种机制并不是 HTML 当前规范的一部分。和书签管理以及前进/后退按钮一样，它也是浏览器在多年发展中的产物。很多网站都普遍存在着一些已知的无效 HTML 结构，每一种浏览器都会尝试通过和其他浏览器一样的方式来修复这些无效结构。

HTML5 规范定义了一部分这样的要求。WebKit 在 HTML 解析器类的开头注释中对此做了很好的概括。

> 我们至少要能够处理以下错误情况：
> 
> 1.  明显不能在某些外部标记中添加的元素。在此情况下，我们应该关闭所有标记，直到出现禁止添加的元素，然后再加入该元素。
> 2.  我们不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：HTML HEAD BODY TBODY TR TD LI（还有遗漏的吗？）。
> 3.  向 inline 元素内添加 block 元素。关闭所有 inline 元素，直到出现下一个较高级的 block 元素。
> 4.  如果这样仍然无效，可关闭所有元素，直到可以添加元素为止，或者忽略该标记。

## CSS Parser

