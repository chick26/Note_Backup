#Internet/WebBrowser

# 浏览器高层结构

1.  **用户界面** - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。
2.  **浏览器引擎** - 在用户界面和呈现引擎之间传送指令。
3.  **呈现引擎** - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
4.  **网络** - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。
5.  **用户界面后端** - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
6.  **JavaScript 解释器**。用于解析和执行 JavaScript 代码。
7.  **数据存储**。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库

![](https://gitee.com/chick-lee/typroa_-image_-repo/raw/master/image/202201261438296.png)

# Rendering Engine 呈现引擎 

>默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。

Firefox、Chrome 浏览器和 Safari是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。

## Main Flow

![](https://gitee.com/chick-lee/typroa_-image_-repo/raw/master/image/202201261449245.png)

呈现引擎开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树(Render Tree)。

呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。

呈现树构建完毕之后，进入布局(Layout) 处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是 绘制(Painting) - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。

**PS** 这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。

## Main Flow Examples

### WebKit Main Flow
![](https://gitee.com/chick-lee/typroa_-image_-repo/raw/master/image/202201261500863.png)

### Mozilla's Gecko rendering engine main flow
![](https://gitee.com/chick-lee/typroa_-image_-repo/raw/master/image/202201261501778.png)

# Parsing and DOM tree construction 解析和DOM树构建

解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。

解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为 [[与上下文无关的语法]]。人类语言并不属于这样的语言，因此无法用常规的解析技术进行解析。

## Parsing

### Parser–Lexer combination

>解析器负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。其过程可以分成两个子过程：词法分析和语法分析

解析器通常将解析工作分给以下两个组件来处理：
- **词法分析器**（有时也称为标记生成器），负责将输入内容分解成一个个有效标记，词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词；
- **语法分析**，是应用语言的语法规则的过程。

### Formal definitions for vocabulary and syntax

词汇通常用 [[正则表达式]] 表示。例如，我们的加减计算语言可以定义如下：
```
INTEGER :0|[1-9][0-9]* 
PLUS : + 
MINUS: -
```
语法通常使用一种称为 **BNF** 的格式来定义。我们的示例语言可以定义如下：
```
expression := term  operation  term
operation := PLUS | MINUS
term := INTEGER | expression
```

### Types of parsers

有两种基本类型的解析器：自上而下解析器和自下而上解析器。直观地来说，自上而下的解析器从语法的高层结构出发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则:

- 自上而下的解析器会从高层的规则开始：首先将 `2 + 3` 标识为一个表达式，然后将 `2 + 3 - 1` 标识为一个表达式（标识表达式的过程涉及到匹配其他规则，但是起点是最高级别的规则）。

- 自下而上的解析器将扫描输入内容，找到匹配的规则后，将匹配的输入内容替换成规则。如此继续替换，直到输入内容的结尾。部分匹配的表达式保存在解析器的堆栈中。

### Generating parsers automatically

> **解析器生成器**。只要向其提供所用语言的语法（词汇和语法规则），它就会生成相应的解析器。创建解析器需要对解析有深刻理解，而人工创建并优化解析器并不是一件容易的事情，所以解析器生成器是非常实用的。

WebKit 使用了两种非常有名的解析器生成器：用于创建词法分析器的 **Flex** 以及用于创建解析器的 **Bison**（Lex / Yacc ）。Flex 的输入是包含标记的正则表达式定义的文件。Bison 的输入是采用 BNF 格式的语言语法规则。

## HTML Parser

>HTML 解析器的任务是将 HTML 标记解析成解析树。

- DTD（Document Type Definition，文档类型定义）格式，非与上下文无关语法，属于 **标准通用标记语言**（Standard Generalized Markup Language，**SGML**），是现时常用的超文本格式的最高层次标准，是可以定义标记语言的元语言，甚至可以定义不必采用< >的常规方式。由于它的复杂，因而难以普及。
- 区别于 XML ，HTML 的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性”的语法。
- HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 XML 解析器来解析。

### DOM

>解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。  




